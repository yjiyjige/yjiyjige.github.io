<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="YJIYJIGE BLOG">
<meta property="og:url" content="http://yjiyjige.github.io/index.html">
<meta property="og:site_name" content="YJIYJIGE BLOG">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YJIYJIGE BLOG">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> YJIYJIGE BLOG </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">YJIYJIGE BLOG</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">He is so lazy and nothing left~</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/10/learning-swift-6/" itemprop="url">
                  Swift学习笔记（六）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-10T22:35:44+08:00" content="2015-08-10">
              2015-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/08/10/learning-swift-6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/10/learning-swift-6/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p><strong>存储属性</strong>（Stored Properties）就是在特定类或结构体的实例中的一个常量或变量。存储属性可以分为<strong>变量存储属性</strong>和<strong>常量存储属性</strong>。</p>
<p>如果创建一个结构体实例，并赋值给一个常量，则无法修改实例的任何属性，即使定义了变量存储属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FixedLengthRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstValue: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> length: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rangeOfThreeItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">3</span>)</span><br><span class="line">rangeOfThreeItems.firstValue = <span class="number">5</span> <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>这是因为结构体是值类型，当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>
<h2 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h2><p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用<code>lazy</code>来标识。</p>
<p>注意：延迟存储属性必须是变量，因为其值在类构造之前可能无法得到，而常量属性在构造过程完成之前必须要有初始值。</p>
<h2 id="存储属性-1"><a href="#存储属性-1" class="headerlink" title="存储属性"></a>存储属性</h2><p><strong>计算属性</strong>（Computed Properties）不直接存储值，而是提供一个<code>getter</code>来获取值，一个可选的<code>setter</code>来间接设置其他属性或变量的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - (size.width / <span class="number">2</span>)</span><br><span class="line">            origin.y = newCenter.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>), size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter = square.center <span class="comment">// 取值</span></span><br><span class="line">square.center = <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>) <span class="comment">// 设置值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"square.origin is now at (<span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>)"</span>)</span><br></pre></td></tr></table></figure>
<p>如果计算属性的<code>setter</code>没有定义新值的参数名，默认名称为<code>newValue</code>。</p>
<p>如果计算属性只有<code>getter</code>而没有<code>setter</code>这个称为只读计算属性。可以直接省去<code>get</code>和花括号。</p>
<h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><p>属性观察器监控和响应属性值的变化。每次属性被设置值的时候都会调用属性观察器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123; <span class="comment">// 在设置之前调用，参数是值进来的值</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"About to set totalSteps to <span class="subst">\(newTotalSteps)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123; <span class="comment">// 设置之后调用</span></span><br><span class="line">            <span class="keyword">if</span> totalSteps &gt; oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Added <span class="subst">\(totalSteps - oldValue)</span> steps"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stepCounter = <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>不管类型有多少个实例，一个类型属性只有一份。</p>
<p>对于值类型（指结构体和枚举）可以定义存储型和计算型类型属性，对于类（class）则只能定义计算型类型属性。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/08/learning-swift-5/" itemprop="url">
                  Swift学习笔记（五）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-08T14:54:28+08:00" content="2015-08-08">
              2015-08-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/08/08/learning-swift-5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/08/learning-swift-5/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><strong>枚举</strong>（Enumerations）定义了一个通用类型的一组相关的值。</p>
<p>在Swift中，枚举是一等类型。可以使用许多类所支持的特征。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：一个<code>switch</code>语句中的<code>case</code>必须是全面覆盖的。所以如果在<code>switch</code>中使用枚举，又没有<code>case</code>所有枚举值，那么必须加上<code>default</code>分支。</p>
<h2 id="相关值"><a href="#相关值" class="headerlink" title="相关值"></a>相关值</h2><p>Swift的枚举可以存储任何类型的<strong>相关值</strong>（Associated Values）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UPCA</span>(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">QRCode</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">85909_51226</span>, <span class="number">3</span>)</span><br><span class="line">productBarcode = <span class="type">Barcode</span>.<span class="type">QRCode</span>(<span class="string">"abcdefg"</span>)</span><br><span class="line"><span class="comment">// 提取值</span></span><br><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">UPCA</span>(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> identifier, <span class="keyword">let</span> check):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"UPC-A with value of <span class="subst">\(numberSystem)</span>, <span class="subst">\(identifier)</span>, <span class="subst">\(check)</span>."</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">QRCode</span>(<span class="keyword">let</span> productCode):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"QR code with value of <span class="subst">\(productCode)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">UPCA</span>(numberSystem, identifier, check):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"UPC-A with value of <span class="subst">\(numberSystem)</span>, <span class="subst">\(identifier)</span>, <span class="subst">\(check)</span>."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">QRCode</span>(productCode):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"QR code with value of <span class="subst">\(productCode)</span>."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><p>Swift枚举成员可以被<strong>默认值</strong>（Raw Values）预先填充，这些值具有相同类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123; <span class="comment">// 带有类型</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tab</span> = <span class="string">"\t"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LineFeed</span> = <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">CarriageReturn</span> = <span class="string">"\r"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原始值可以是字符串、字符、任何整型或浮点值。每个原始值在其枚举声明中必须是唯一的。当整型值被用于原始值，如果其他枚举成员没有值，它们会自动递增。使用枚举的<code>rawValue</code>属性访问原始值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span>, <span class="type">Venus</span> = <span class="number">2</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(Planet.Mercury.rawValue)</span>"</span>)</span><br><span class="line"><span class="comment">// Mercury = 0 从0开始</span></span><br><span class="line"><span class="comment">// Earth = 3 后面类推</span></span><br></pre></td></tr></table></figure>
<p>可能通过参数<code>rawValue</code>构造函数创建特定原始值的枚举，该构造方法返回的是一个可选类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positionToFind = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> somePlanet = <span class="type">Planet</span>(rawValue: positionToFind) &#123; <span class="comment">// somePlanet不一定存在</span></span><br><span class="line">    <span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Earth</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Mostly harmless"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Not a safe place for humans"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"There isn't a planet at position <span class="subst">\(positionToFind)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h2><p>在Swift中类和结构体有很多共同点：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义附属脚本用于访问值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展增加默认实现的功能</li>
<li>符合协议以对某类提供标准功能</li>
</ul>
<p>与结构体相比，类还有如下附加功能：</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>解构器允许一个类实例释放任何其所分配的资源</li>
<li>引用计数器允许对一个类的多次引用</li>
</ul>
<p>定义一个类或结构体时，实际上是定义了一个新的Swift类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width =  <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hdResolution = <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure>
<p>所有结构体都有一个自动生成的成员逐一构造器，新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga = <span class="type">Resoution</span>(width:<span class="number">640</span>, height:<span class="number">480</span>) <span class="comment">// 自动生成</span></span><br></pre></td></tr></table></figure>
<h2 id="结构体和枚举是值类型"><a href="#结构体和枚举是值类型" class="headerlink" title="结构体和枚举是值类型"></a>结构体和枚举是值类型</h2><p>值类型被赋予一个变量，常量或者本身被传递给一个函数的时候，实际上操作的是其的拷贝。这是因为在Swift中结构体和枚举是值类型的，所以它们的实例以及实例中包含的任何值类型属性，在代码中传递的时候都会被复制。</p>
<h2 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h2><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，操作的是引用，其并不是拷贝。</p>
<p>判断两个常量或变量在后台同时引用同一个类实例时，使用Swift内建的恒等运算符：</p>
<ul>
<li>等价于<code>===</code></li>
<li>不等价于<code>!==</code></li>
</ul>
<h2 id="类和结构体的选择"><a href="#类和结构体的选择" class="headerlink" title="类和结构体的选择"></a>类和结构体的选择</h2><p>按照通用的准则，当符合一个或多个以下条件时，考虑使用结构体：</p>
<ul>
<li>结构体的主要作用是封装少量相关、简单的数据值</li>
<li>有理由预计一个结构体实例在赋值传递时，封闭的数据需要被拷贝而不是被引用</li>
<li>任何结构体中储存的值类型属性，也将会被拷贝，而不是被引用</li>
<li>结构体不需要去继承另一个已存在类型的属性或行为</li>
</ul>
<p>大部分情况下，应该使用的是类而非结构体。</p>
<p>Swift中，字符串、数组、字典均以结构体的形式实现。所以赋值与传递函数的情况都会发生拷贝行为。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/02/learning-swift-4/" itemprop="url">
                  Swift学习笔记（四）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-02T08:09:23+08:00" content="2015-08-02">
              2015-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/08/02/learning-swift-4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/02/learning-swift-4/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote>
<p>函数是用来完成特定任务的独立代码块。</p>
</blockquote>
<p>Swift中函数的一般形式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(parameter: someType)</span></span> -&gt; returnType &#123;</span><br><span class="line">    <span class="comment">// function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的参数与返回值"><a href="#函数的参数与返回值" class="headerlink" title="函数的参数与返回值"></a>函数的参数与返回值</h2><p>如果一个函数不需返回值，可以不需要<code>-&gt;</code>后面的返回类型。但实际上，没有定义返回类型的函数会返回特殊的值<code>Void</code>，它其实是一个空的元组，写成<code>()</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumber</span><span class="params">(num: Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"The number is <span class="subst">\(num)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printNumber(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> returnValue = printNumber(<span class="number">0</span>) <span class="comment">// 不会编译错误，会警告</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The return value is <span class="subst">\(returnValue)</span>"</span>) <span class="comment">// The return value is ()</span></span><br></pre></td></tr></table></figure>
<p>Swift函数支持返回一个元组，也即可以同时返回多个值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMessage</span><span class="params">()</span></span> -&gt; (statusCode: <span class="type">Int</span>, content: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">400</span>, <span class="string">"Page no found"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> message = getMessage()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"Status code: <span class="subst">\(message.statusCode)</span> Message: <span class="subst">\(message.content)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>有时候，调用函数时，加上参数的命名可以使代码可读性更好。Swift支持给函数添加<strong>外部参数名</strong>（External Parameter Names），这样在调用函数时，必须显式添加外部参数名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(externalParameterName localParameterName: someType)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joinStr</span><span class="params">(string s1: String, <span class="built_in">toString</span> s2: String, withJoiner joiner: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + joiner +  s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = joinStr(string: <span class="string">"Hello"</span>, <span class="built_in">toString</span>: <span class="string">"World"</span>, withJoiner: <span class="string">" "</span>)</span><br><span class="line"><span class="built_in">println</span>(result)</span><br></pre></td></tr></table></figure>
<p>如果外部参数名与局部参数名一样，不需要写两次，只需要在参数前添加一个<code>#</code>。</p>
<p>可以给函数参数定义默认值，如果调用函数时不传递该参数则使用默认值代替。默认值只能放在函数的末尾，因为这样调用时才不会产生歧义。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joinStr</span><span class="params">(string s1: String, <span class="built_in">toString</span> s2: String, withJoiner joiner: String = <span class="string">", "</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + joiner +  s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = joinStr(string: <span class="string">"Hello"</span>, <span class="built_in">toString</span>: <span class="string">"World"</span>)</span><br><span class="line"><span class="built_in">println</span>(result)</span><br></pre></td></tr></table></figure>
<p>当未给带默认值参数提供外部参数名时，Swift会自动提供一个与局部参数名一致的外部参数名，无需显式添加<code>#</code>。</p>
<p>注意：可以使用下划线<code>_</code>作为默认值参数的外部参数名，但最好不要这么干。</p>
<p>一个<strong>可变参数</strong>（Variadic Parameter）可以接受<strong>零个</strong>或多个值。实际上，可以把该参数当一个数组来看。如果参数是零个，也即数组长度为0，这种情况需要特别注意。一个函数最多只能有一个可变参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">avg</span><span class="params">(datas: Int...)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> datas &#123;</span><br><span class="line">        total += <span class="type">Double</span>(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total / <span class="type">Double</span>(datas.<span class="built_in">count</span>) <span class="comment">// 这里可能有异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The avg is <span class="subst">\(avg(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span>)"</span>)</span><br></pre></td></tr></table></figure>
<p>如果一个函数有一个或多个带默认值的参数，而且还有一个可变参数，那么可变参数要放在最后。</p>
<p><strong>Swift函数参数默认是常量</strong>！如果需要修改参数值，需要在参数名前加一个<code>var</code>。</p>
<p>变量参数仅仅能在函数内被更改，如果需要修改参数外部的传递值，需要将该参数定义为<strong>输入输出参数</strong>（In-Out Parameters）。但注意，只能修改变量实参，不能修改常量或者字面量，因为它们不可修改。传入的参数前需要加<code>&amp;</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">5</span></span><br><span class="line">swapInt(&amp;a, &amp;b) <span class="comment">// 类似c语言的取地址</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"a is <span class="subst">\(a)</span> b is <span class="subst">\(b)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>注意：输入输出参数不能有默认值，而且可变参数不能用<code>inout</code>标记。如果你用<code>inout</code>标记一个参数，这个参数不能被<code>var</code>或者<code>let</code>标记。</p>
<h2 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h2><p>每个函数都有特定的<strong>函数类型</strong>（Function Types），由参数类型和返回类型组成。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multiplyTwoInts</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数的类型一致都为<code>(Int, Int) -&gt; Int</code>。如果一个函数既没有参数也没有返回值类型，那么该函数是类型是<code>() -&gt; ()</code>。</p>
<p>在Swift中，使用函数类型就像使用其他类型一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> swapFunc: (<span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">inout</span> <span class="type">Int</span>) -&gt; () = swapInt</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">5</span></span><br><span class="line">swapFunc(&amp;a, &amp;b) <span class="comment">// 与swapInt是一样的</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"a is <span class="subst">\(a)</span> b is <span class="subst">\(b)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherSwapFunc = swapFunc <span class="comment">// 也能够类型推断</span></span><br></pre></td></tr></table></figure>
<p>函数类型可以作为函数的参数类型，这样可以将函数的一部分实现由函数的调用者提供。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, a: <span class="type">Int</span>, b: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Result: <span class="subst">\(mathFunction(a, b)</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>同理，函数类型也可以作为函数的返回类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>把函数定义在函数中，称为<strong>嵌套函数</strong>（Nested Functions）。默认情况下，嵌套函数只能在它们的外部函数中访问，对外界不可见。但嵌套函数可以当作函数的返回值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input - <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>闭包是<strong>自包含</strong>的函数代码块，可以在代码中被传递和使用。</p>
</blockquote>
<p><strong>闭包</strong>（Closures）可以捕获和存储其上下文中任意常量和变量的引用，也就是所谓的闭合并包裹着这些常量和变量，俗称闭包。</p>
<p><strong>全局函数和嵌套函数实际上也是闭包</strong>，闭包有如下三种形式：</p>
<ol>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并且可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量语法所写成的可以捕获其上下文中变量或常量的匿名闭包</li>
</ol>
<p>Swift的闭包表达式拥有简洁的风格，推荐在常见场景中进行语法优化，如下：</p>
<ul>
<li>利用上下文推断参数类型和返回值类型</li>
<li>隐式返回单表达式闭包，可以省略<code>return</code>关键字</li>
<li>使用参数名称缩写</li>
<li>使用尾随闭包语法</li>
</ul>
<h2 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h2><p><strong>闭包表达式</strong>（Closure Expressions）是一种利用简洁语法构建内联闭包的方式。</p>
<p>一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用传递函数实现</span></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backwards</span><span class="params">(s1: String, s2: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sortedNames = sorted(names, backwards)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(sortedNames)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>上述例子中<code>backwards</code>只用了一次，实在浪费。可以通过闭包表达式实现，一般的闭包表达式完整结构如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>parameters</code>和<code>returnType</code>与普通函数是完全一样的。可以得到第一个优化版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNames = sorted(names, &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上述例子中，<code>sorted</code>函数的第二个参数的类型<code>(String, String) -&gt; Bool</code>是确定的。所以其实闭包的参数类型与返回值类型是可以省略的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNames = sorted(names, &#123; (s1, s2) <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125;)</span><br><span class="line">或</span><br><span class="line"><span class="keyword">let</span> sortedNames = sorted(names, &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125;)</span><br></pre></td></tr></table></figure>
<p>对于单行的表达式，其<code>return</code>也是可以省略的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNames = sorted(names, &#123; s1, s2 <span class="keyword">in</span> s1 &gt; s2 &#125;)</span><br></pre></td></tr></table></figure>
<p>Swift会自动为内联函数提供参数名称缩写，可以直接使用<code>$0</code>、<code>$1</code>、<code>$2</code>来调用闭包参数。同时关键字<code>in</code>也是可以省略的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNames = sorted(names, &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h2><p>如果需要将一个很长的闭包表达式作为<strong>最后</strong>一个参数传递给函数，可以使用<strong>尾随闭包</strong>（Trailing Closures）来增强函数的可读性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNames = sorted(names) &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><p>闭包可以在其定义的上下文中捕获常量和变量。即使定义这些常量和变量的原域已经不存在，闭包仍然可以引用到。Swift会决定捕获引用还是拷贝值，同时处理变量的内存管理。</p>
<h2 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h2><p>函数和闭包都是引用类型的，将函数或闭包赋给一个常量或变量，实际上是将常量或变量设置为对应函数或闭包的引用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/01/learning-swift-3/" itemprop="url">
                  Swift学习笔记（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-01T16:00:35+08:00" content="2015-08-01">
              2015-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/08/01/learning-swift-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/01/learning-swift-3/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h2><p><code>for-in</code>循环用来遍历一个集合中所有元素，集合可以区间、数组、字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123; <span class="comment">// index是常量</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(index)</span> time 5 is <span class="subst">\(<span class="number">5</span> * index)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Hello, <span class="subst">\(name)</span>!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (animalName, legCount) <span class="keyword">in</span> numberOfLegs &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(animalName)</span>s have <span class="subst">\(legCount)</span> legs"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Hello"</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(character)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不需要知道区间内每一项的值，可以使用下划线<code>_</code>替代变量名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> base = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> power = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> answer = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...power &#123;</span><br><span class="line">    answer *= base</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(base)</span> to the power of <span class="subst">\(power)</span> is <span class="subst">\(answer)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>另一种形式的<code>for</code>循环称为<strong>For条件递增</strong>（For Condition Increment）,一般形式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> initializaion; condition; increment &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h2><p><code>while</code>循环运行一系列语句直到条件变成假。Swift中有两种形式的<code>while</code>循环：</p>
<ol>
<li><code>while</code>循环，每次循环开始判断条件是否符合</li>
<li><code>do-while</code>循环，循环语句执行完之后判断条件是否符合</li>
</ol>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>Swift的<code>switch</code>语句比C语言强大得多，一个<code>case</code>支持多个条件，并且不存在隐式贯穿的问题，如果确实需要使用贯穿的特性，需要手动加<code>fallthrough</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> = <span class="string">"e"</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>: <span class="comment">// 支持多个条件</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is a vowel"</span>) <span class="comment">// 不会贯穿</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>,</span><br><span class="line">     <span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is a consonant"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is not a vowel or a consonant"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "e is a vowel"</span></span><br></pre></td></tr></table></figure>
<p><code>switch</code>语言还支持区间匹配：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">3_000_000_000_000</span></span><br><span class="line"><span class="keyword">let</span> countedThings = <span class="string">"stars in the Milky Way"</span></span><br><span class="line"><span class="keyword">var</span> naturalCount: <span class="type">String</span></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">count</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    naturalCount = <span class="string">"no"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...<span class="number">3</span>:</span><br><span class="line">    naturalCount = <span class="string">"a few"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>...<span class="number">9</span>:</span><br><span class="line">    naturalCount = <span class="string">"several"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>...<span class="number">99</span>:</span><br><span class="line">    naturalCount = <span class="string">"tens of"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span>...<span class="number">999</span>:</span><br><span class="line">    naturalCount = <span class="string">"hundreds of"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1000</span>...<span class="number">999_999</span>:</span><br><span class="line">    naturalCount = <span class="string">"thousands of"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    naturalCount = <span class="string">"millions and millions of"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"There are <span class="subst">\(naturalCount)</span> <span class="subst">\(countedThings)</span>."</span>)</span><br><span class="line"><span class="comment">// 输出 "There are millions and millions of stars in the Milky Way."</span></span><br></pre></td></tr></table></figure>
<p><code>switch</code>支持使用元组在同一个<code>case</code>中匹配多个值。元组中的元素可以具体的值，也可以是区间，使用下划线<code>_</code>匹配所有可能的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somePoint = (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> somePoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"(0, 0) is at the origin"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">_</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, 0) is on the x-axis"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"(0, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is on the y-axis"</span>)</span><br><span class="line"><span class="keyword">case</span> (-<span class="number">2</span>...<span class="number">2</span>, -<span class="number">2</span>...<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is inside the box"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is outside of the box"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>case</code>分支支持将匹配的值绑定到一个临时的常量或变量，以便在接下来使用。这种形为称为<strong>值绑定</strong>（Value Binding）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint = (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"on the x-axis with an x value of <span class="subst">\(x)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"on the y-axis with a y value of <span class="subst">\(y)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>case</code>分支的模式可以使用<code>where</code>语句来判断额外的条件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint = (<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用标签来标记一个循环体或<code>switch</code>代码块，当使用<code>break</code>或者<code>continue</code>时，带上这个标签，可以控制标签代表对象的中断或者执行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gameLoop: <span class="keyword">while</span> square != finalSquare &#123;</span><br><span class="line">    <span class="keyword">if</span> ++diceRoll == <span class="number">7</span> &#123; diceRoll = <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">switch</span> square + diceRoll &#123;</span><br><span class="line">    <span class="keyword">case</span> finalSquare:</span><br><span class="line">        <span class="comment">// 到达最后一个方块，游戏结束</span></span><br><span class="line">        <span class="keyword">break</span> gameLoop</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare &gt; finalSquare:</span><br><span class="line">        <span class="comment">// 超出最后一个方块，再掷一次骰子</span></span><br><span class="line">        <span class="keyword">continue</span> gameLoop</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 本次移动有效</span></span><br><span class="line">        square += diceRoll</span><br><span class="line">        square += board[square]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"Game over!"</span>)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/01/learning-swift-2/" itemprop="url">
                  Swift学习笔记（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-01T07:58:55+08:00" content="2015-08-01">
              2015-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/08/01/learning-swift-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/01/learning-swift-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><p>Swift支持大部分C语言运算符，并且添加许多新特性来减少常规编码错误。比如赋值号<code>=</code>不返回值、算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>等）会检测并且不允许值溢出。</p>
<p>元组赋值可理解为把元组分解成单个元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"the x is <span class="subst">\(x)</span>"</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"the y is <span class="subst">\(y)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>Swift支持对浮点数进行求余：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> division = <span class="number">5.0</span> % <span class="number">2.0</span> <span class="comment">// 1.0</span></span><br></pre></td></tr></table></figure>
<p>Swift提供<strong>恒等</strong>（<code>===</code>）和<strong>不恒等</strong>（<code>!==</code>）运算符，用来判断两个变量是否引用同一个实例。</p>
<h2 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h2><p><strong>空合运算符</strong>（Nil Coalescing Operator）<code>a ?? b</code>，将可选类型<code>a</code>进行判空处理，如果<code>a</code>包含值就进行解封，否则返回一个默认值<code>b</code>。空合运算符需要满足两个条件：</p>
<ol>
<li>表达式中的<code>a</code>必须是可选类型</li>
<li>默认值<code>b</code>的类型必须和<code>a</code>的存储值类型一致</li>
</ol>
<p>空合运算符其实是对下列表达式的简写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a != <span class="literal">nil</span> ? a! : b</span><br></pre></td></tr></table></figure>
<p>注意一点，该运算符具有“短路”特性，如果<code>a</code>有值，那么返回的是<code>a</code>的存储值，<code>b</code>表达式不会被执行。</p>
<h2 id="区间运行符"><a href="#区间运行符" class="headerlink" title="区间运行符"></a>区间运行符</h2><p><strong>闭区间运算符</strong><code>a...b</code>，定义一个包含从<code>a</code>到<code>b</code>所有值的区间，<code>b</code><strong>必须大于</strong><code>a</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(index)</span> * 5 = <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 * 5 = 5</span></span><br><span class="line"><span class="comment">// 2 * 5 = 10</span></span><br><span class="line"><span class="comment">// 3 * 5 = 15</span></span><br><span class="line"><span class="comment">// 4 * 5 = 20</span></span><br><span class="line"><span class="comment">// 5 * 5 = 25</span></span><br></pre></td></tr></table></figure>
<p><strong>半开区间运算符</strong><code>a..&lt;b</code>，定义一个从<code>a</code>开始到<code>b</code>但不包括<code>b</code>的区间。对数组下标之类操作很有用。</p>
<h2 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h2><p><strong>字符串</strong>（String）是有序的<strong>字符</strong>（Character）类型的值的集合。</p>
<p><strong>字符串是值类型的</strong>。一个新的字符串对其进行常量、变量赋值或者是在函数中传递时，会进行值拷贝。可以保证原来的字符串不被修改。</p>
<p>通过标明一个<code>Character</code>类型注解并通过字符字面量进行赋值，可以建立一个独立的字符常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yenSign: <span class="type">Character</span> = <span class="string">"¥"</span> <span class="comment">// 明确指明不是String类型</span></span><br></pre></td></tr></table></figure>
<p>字符串长度可以用全局函数<code>count</code>获得：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> country = <span class="string">"China"</span></span><br><span class="line"><span class="keyword">let</span> length = <span class="built_in">count</span>(country)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"the String length is <span class="subst">\(length)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>注意：不同的Unicode字符以及相同Unicode字符的不同表示方式可能需要不同数量的内存空间来存储。所以Swift中的字符在一个字符串中并不一定占用相同的内存空间。</p>
<p><strong>字符串插值</strong>（String Interpolation）是一种构建新字符串的方式，可以将常量、变量、字面量、表达式插入到字符串中每一项包裹在<code>\()</code>中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiplier = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"<span class="subst">\(multiplier)</span> 乘以 2.5 是 <span class="subst">\(Double(multiplier)</span> * 2.5)"</span></span><br></pre></td></tr></table></figure>
<p>判断字符串相等可以直接用<code>==</code>判断。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组</strong>（Array）使用有序列表存储同一类型多个值，相同的值可以多次出现在不同位置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList: [<span class="type">String</span>] = [<span class="string">"eggs"</span>, <span class="string">"milk"</span>]</span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"eggs"</span>, <span class="string">"milk"</span>] <span class="comment">// 自动类型推断为[String]</span></span><br></pre></td></tr></table></figure>
<p>上述例子中<code>shoppingList</code>称为”字符串类型的数组“，数组中的元素只能为字符串类型。</p>
<p>Swift中数组支持使用<code>+</code>或<code>+=</code>将两个类型一致的数组进行拼接：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> students1 = [<span class="string">"yjiyjige"</span>, <span class="string">"xiaomin"</span>]</span><br><span class="line"><span class="keyword">let</span> students2 = [<span class="string">"zhangsan"</span>, <span class="string">"lishi"</span>]</span><br><span class="line"><span class="keyword">let</span> allStudents = students1 + students2</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"all students <span class="subst">\(allStudents)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>数组下标支持区间运算符，用于截取数组中的某一段。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> students = [<span class="string">"yjiyjige"</span>, <span class="string">"xiaomin"</span>, <span class="string">"zhangsan"</span>, <span class="string">"lishi"</span>]</span><br><span class="line"><span class="keyword">let</span> subStudents = students[<span class="number">0</span>...<span class="number">2</span>] <span class="comment">// [yjiyjige, xiaomin, zhangsan]</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"all students <span class="subst">\(subStudents)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>使用<code>for-in</code>循环来遍历数组时，如果同时需要数据项与对应的索引值，可以使用全局函数<code>enumerate</code>来遍历：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> students = [<span class="string">"yjiyjige"</span>, <span class="string">"xiaomin"</span>, <span class="string">"zhangsan"</span>, <span class="string">"lishi"</span>]</span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> <span class="built_in">enumerate</span>(students) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"student at <span class="subst">\(index)</span> is <span class="subst">\(value)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用构造语法<code>[someType]()</code>来创建一个特定数据类型构成的空数组:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts = [<span class="type">Int</span>]()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"someInts is of type [Int] with <span class="subst">\(someInts.<span class="built_in">count</span>)</span> items。"</span>)</span><br><span class="line">someInts.append(<span class="number">3</span>) <span class="comment">// someInts现在包含一个INT值</span></span><br><span class="line">someInts = [] <span class="comment">// someInts现在是空数组，但是仍然是[Int]类型的。</span></span><br></pre></td></tr></table></figure>
<p>Swift中数组类型提供一个可以创建特定大小并且所有数据都被设置为默认值的构造方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tenString = [<span class="type">String</span>](<span class="built_in">count</span>: <span class="number">10</span>, repeatedValue: <span class="string">"hello"</span>)</span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">var</span> tenString = <span class="type">Array</span>(<span class="built_in">count</span>: <span class="number">10</span>, repeatedValue: <span class="string">"hello"</span>) <span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><strong>集合</strong>（Set）用来存储相同类型但没有确定顺序的值，值相同的元素只能有一个。</p>
<p>Swift中集合类型用<code>Set&lt;someType&gt;</code>表示，<code>someType</code>是集合支持的存储类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line">letters.insert(<span class="string">"a"</span>) <span class="comment">// letters现在含有1个Character类型的值</span></span><br><span class="line">letters = [] <span class="comment">// letters现在是一个空的Set, 但是它依然是Set&lt;Character&gt;类型</span></span><br></pre></td></tr></table></figure>
<p>可以使用一个数组字面量来构造一个集合，并且可以使用简化形式初始化一个或多个集合元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br><span class="line"> <span class="comment">// 可以去掉Set后面的类型，因为可以自动类型推断；但Set就不能去了，因为默认是Array</span></span><br><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span> = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br></pre></td></tr></table></figure>
<p>集合类型元素是没有顺序的，为了按照特定顺序来遍历一个集合中的值，可以使用全局函数<code>sorted</code>，它将返回一个排好序的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> students: <span class="type">Set</span> = [<span class="string">"yjiyjige"</span>, <span class="string">"xiaomin"</span>, <span class="string">"zhangsan"</span>, <span class="string">"lishi"</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> sorted(students) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(name)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result: [lishi, xiaomin, yjiyjige, zhangsan]</span></span><br></pre></td></tr></table></figure>
<p>Swift中集合支持<strong>交集</strong>、<strong>差集</strong>、<strong>并集</strong>、<strong>排除</strong>操作：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png" alt="Set Venn Diagram"></p>
<p>集合之间的元素不同有如下情况：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png" alt="Set Euler Diagram"></p>
<ul>
<li>使用“是否等”运算符<code>==</code>来判断两个集合是否包含相同的值</li>
<li>使用<code>isSubsetOf()</code>方法来判断一个集合中的值是否也被包含在另外一个集合中</li>
<li>使用<code>isSupersetOf()</code>方法来判断一个集合中包含的值是另一个集合中所有的值</li>
<li>使用<code>isStrictSubsetOf()</code>方法来判断一个集合是否是另外一个集合的子集合并且和特定集合不相等</li>
<li>使用<code>isStrictSupersetOf()</code>方法来判断一个集合是否是另外一个集合的父集合并且和特定集合不相等</li>
<li>使用<code>isDisjointWith()</code>方法来判断两个结合是否不含有相同的值</li>
</ul>
<p>存储在集合中的元素必须是可以哈希化的，其哈希值用来判断与其它对象是否相同。<code>a == b</code>遵循的是<code>a.hashValue == b.hashValue</code>。</p>
<p>相等运算符<code>==</code>符合以下性质：</p>
<ul>
<li>自反性 <code>a == a</code>为真</li>
<li>对称性 如<code>a == b</code>则<code>b == a</code></li>
<li>传递性 如<code>a == b</code>且<code>b == c</code>则<code>a == c</code></li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是一种存储<strong>键</strong>（Key）<strong>值</strong>（Value）对的容器。键是字典元素的标识符，相同值只能有一个。字典中元素并没有具体顺序，需要通过键进行访问。</p>
<p>Swift中字典使用<code>Dictionary&lt;KeyType, ValueType&gt;</code>定义，<code>KeyType</code>必须是可以哈希的。</p>
<p>字典也可以使用字面量进行初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>:<span class="type">String</span>] = [<span class="string">"TYO"</span>: <span class="string">"Tokyo"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br><span class="line">等同于：</span><br><span class="line"><span class="keyword">var</span> airports = [<span class="string">"TYO"</span>: <span class="string">"Tokyo"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br></pre></td></tr></table></figure>
<p>字典下标支持使用健来访问和修改对应元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports = [<span class="string">"TYO"</span>: <span class="string">"Tokyo"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br><span class="line"><span class="keyword">var</span> country = airports[<span class="string">"TYO"</span>] <span class="comment">// 这里返回的是可选类型</span></span><br><span class="line"><span class="built_in">println</span>(country!)</span><br><span class="line">airports[<span class="string">"TYO"</span>] = <span class="string">"China"</span> <span class="comment">// 修改值</span></span><br><span class="line">airports[<span class="string">"TYO"</span>] = <span class="literal">nil</span> <span class="comment">// 删除元素</span></span><br><span class="line">airports[<span class="string">"TYOA"</span>] = <span class="string">"China"</span> <span class="comment">// 如果键不存在，则会添加一个新的元素</span></span><br></pre></td></tr></table></figure>
<p>使用<code>for-in</code>循环来遍历某个字典中的键值对。每一个字典中的数据项都由(key, value)元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(airportCode)</span>: <span class="subst">\(airportName)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建字典的语法与数组很类似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namesOfIntegers = <span class="type">Dictionary</span>&lt;<span class="type">Int</span>, <span class="type">String</span>&gt;()</span><br><span class="line">namesOfIntegers[<span class="number">16</span>] = <span class="string">"sixteen"</span> <span class="comment">// namesOfIntegers现在包含一个键值对</span></span><br><span class="line">namesOfIntegers = [:] <span class="comment">// namesOfIntegers还是[Int, String]类型的空字典</span></span><br></pre></td></tr></table></figure>
<h2 id="集合的可变性"><a href="#集合的可变性" class="headerlink" title="集合的可变性"></a>集合的可变性</h2><p>创建一个数组或者字典并且把它分配成一个变量，这个集合将会是可变的，也就是可以添加更多或移除已存在的数据项来改变这个集合的大小；把数组或字典分配成常量，那么它就是不可变的，它的大小不能被改变。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/31/learning-swift-1/" itemprop="url">
                  Swift学习笔记（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-31T20:59:45+08:00" content="2015-07-31">
              2015-07-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/31/learning-swift-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/31/learning-swift-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hello-Swift"><a href="#Hello-Swift" class="headerlink" title="Hello Swift"></a>Hello Swift</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello world"</span>)</span><br></pre></td></tr></table></figure>
<p>可以看出Swift有几个特点：</p>
<ul>
<li>基本的IO和String不需要导入包</li>
<li>不需要<code>main</code>方法</li>
<li>可以不加分号（该加的时候还是得加的，比如一行写多个语句）</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Swift包含C和Obj-C的所有基本数据类型，同时有：</p>
<ul>
<li><code>Int</code> 整型</li>
<li><code>Float</code> 浮点型</li>
<li><code>Double</code> 双精度浮点型</li>
<li><code>Character</code> 字符型</li>
<li><code>Bool</code> 布尔型</li>
<li><code>String</code> 文本型</li>
</ul>
<p>Swift使用<code>let</code>声明常量、使用<code>var</code>声明变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxLength = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> currentLength = <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>用<code>var</code>声明的变量不初始化之前是不知道类型的，一但初始化后变量类型就可以由Swift推导确定下来。另外，也可以通过<strong>类型声明</strong>（Type Annotation）来显式指定变量的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span> <span class="comment">// 类型推导为Int型</span></span><br><span class="line"><span class="keyword">var</span> money: <span class="type">Float</span> = <span class="number">10</span> <span class="comment">// 如果不指明money将是Int型</span></span><br></pre></td></tr></table></figure>
<p>一旦变量的类型确定就不能更改了，同时不能将常量与变量互相转换。</p>
<h2 id="类型安全与类型推断"><a href="#类型安全与类型推断" class="headerlink" title="类型安全与类型推断"></a>类型安全与类型推断</h2><p>Swift是一个<strong>类型安全</strong>（Type Safe）的语言，在编译时会进行<strong>类型检查</strong>（Type Checks），类型不匹配的会被标记为错误。</p>
<p>在Swift中，变量声明不一定要明确指明变量的类型，Swift会使用<strong>类型推断</strong>（Type Inference）来选择合适的类型。</p>
<p>整型数的字面量有如下几种类型：</p>
<ul>
<li>十进制，没有前缀</li>
<li>二进制，前缀为<code>0b</code></li>
<li>八进制，前缀为<code>0o</code></li>
<li>十六进制，前缀为<code>0x</code></li>
</ul>
<p>数值类型字面量可以包括额外格式来增强可读性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> paddedDouble = <span class="number">000123.456</span></span><br><span class="line"><span class="keyword">let</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> justOverOneMillion = <span class="number">1_000_000.000_000_1</span></span><br></pre></td></tr></table></figure>
<h2 id="数值型类型转换"><a href="#数值型类型转换" class="headerlink" title="数值型类型转换"></a>数值型类型转换</h2><p>一般来说，即使代码中的整数常量和变量已知非负，也请使用<code>Int</code>类型。使用默认的整数类型可以保证整数常量和变量可以直接被复用并且可以匹配整数类型字面量的类型推断。</p>
<p>Swift类型转换通常是要明确指定的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> var2 = <span class="number">10.0</span></span><br><span class="line"><span class="keyword">var</span> sum = var1 + var2 <span class="comment">// 错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> var1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> var2 = <span class="number">10.0</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="type">Double</span>(var1) + var2 <span class="comment">// 对</span></span><br></pre></td></tr></table></figure>
<p>注意：字面量<code>3</code>可以直接和字面量<code>0.14159</code>相加。<strong>因为数字字面量本身没有明确的类型</strong>。它们的类型只在编译器需要求值的时候被推测。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><strong>类型别名</strong>（Type Aliases）就是给现有类型定义另一个名字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> = <span class="type">UInt16</span></span><br></pre></td></tr></table></figure>
<p>定义了一个类型别名之后，可以在任何使用原始名的地方使用别名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> = <span class="type">UInt16</span></span><br><span class="line"><span class="keyword">var</span> maxAmplitudeFound = <span class="type">AudioSample</span>.<span class="built_in">min</span> <span class="comment">// 相当于UInt16.min</span></span><br></pre></td></tr></table></figure>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p><strong>元组</strong>（Tuples）是把多个值组合成一个复合值。元组内的值可以是任意类型，不要求相同。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error = (<span class="number">400</span>, <span class="string">"Not Found"</span>)</span><br></pre></td></tr></table></figure>
<p>上述例子<code>http404Error</code>可描述为：一个类型为<code>(Int, String)</code>的元组。</p>
<p>元组可以通过元素位置访问单个元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"The status code is <span class="subst">\(http404Error.<span class="number">0</span>)</span>"</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The status message is <span class="subst">\(http404Error.<span class="number">1</span>)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>另外也可以将一个元组分解成单独的常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The status code is <span class="subst">\(statusCode)</span>"</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The status message is <span class="subst">\(statusMessage)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只需要其中部分元素，忽略的部分用下划线（_）标记</span></span><br><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The status code is <span class="subst">\(justTheStatusCode)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>定义元组时可以给部分或全部元素命名，这样就可以直接通过名字来获取：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http200Status = (statusCode: <span class="number">200</span>, description: <span class="string">"OK"</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The status code is <span class="subst">\(http200Status.statusCode)</span>"</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The status message is <span class="subst">\(http200Status.description)</span>"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>使用<strong>可选类型</strong>（Optionals）来处理值可能缺失的情况。可选类型变量有两种情况：</p>
<ol>
<li>有值，为x</li>
<li>没有值，为nil</li>
</ol>
<p>可选类型通常用来表示值可能缺失的情况。表示为类型加一个<code>?</code>，如<code>Int?</code>。</p>
<p>可选变量赋值为<code>nil</code>表示没有值，如果声明一个可选常量或可选变量没有赋值，默认为<code>nil</code>。</p>
<p>判断一个变量是否有值，与<code>nil</code>进行比较。确认有值时可用<code>!</code><strong>强制解包</strong>（Forced Unwrapping）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String</span>? = <span class="string">"yjiyjige"</span></span><br><span class="line"><span class="keyword">if</span> name != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"name is <span class="subst">\(name!)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<strong>可选绑定</strong>（Optional Binding）来判断可选类型是否包含值，如果包含值赋给一个临时变量或变量。经常用在<code>if</code>或<code>while</code>语句中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = possibleNumber.toInt() &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(possibleNumber)</span> has an integer value of <span class="subst">\(actualNumber)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(possibleNumber)</span> could not be converted to an integer"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隐式解析可选类型"><a href="#隐式解析可选类型" class="headerlink" title="隐式解析可选类型"></a>隐式解析可选类型</h2><p>可选类型暗示了常量或者变量可以“没有值”。可选类型可以通过<code>if</code>语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>
<p>这种类型的可选状态被定义为<strong>隐式解析可选类型</strong>（Implicitly Unwrapped Optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="built_in">println</span>(assumedString)  <span class="comment">// 不需要感叹号</span></span><br></pre></td></tr></table></figure>
<p>隐式解析可选类型主要被用在Swift中类的构造过程中。</p>
<p>如果在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和没有值的普通可选类型一样。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p><strong>断言</strong>（Assert）用来判断某一条件，当结果为<code>true</code>，代码运行会继续进行；如果结果为<code>false</code>，代码运行停止，应用被终止。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = -<span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">"A person's age cannot be less than zero"</span>)</span><br></pre></td></tr></table></figure>
<p>何时使用断言：</p>
<ul>
<li>整数类型的下标索引被传入一个自定义下标脚本实现，但是下标索引值可能太小或者太大</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行</li>
<li>一个可选值现在是<code>nil</code>，但是后面的代码运行需要一个非<code>nil</code>值</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/25/review-c-3/" itemprop="url">
                  重学C语言（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-25T20:51:57+08:00" content="2015-07-25">
              2015-07-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/25/review-c-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/25/review-c-3/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="结构的基础"><a href="#结构的基础" class="headerlink" title="结构的基础"></a>结构的基础</h2><blockquote>
<p>结构是一个或多个变量的集合，变量类型可能不同，集合一起当一个单元处理。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> point &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point p1 = &#123;<span class="number">10</span>, <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>关键字之后的名字是可选的，称为<strong>结构标记</strong>。结构中定义的变量称为<strong>结构成员</strong>。</p>
<h2 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h2><p>结构的合法操作只有几种：作为一个整体复制和赋值、通过<code>&amp;</code>运算符取地址、访问其成员。其中，复制和赋值包括函数传递参数以及从函数返回值。</p>
<p>至少可以通过3种可能的方法传递结构：</p>
<ol>
<li>分别传递各个结构成员</li>
<li>传递整个结构</li>
<li>传递指向结构的指针</li>
</ol>
<p>第一种跟普通函数传递参数没什么区别；当传递整个结构时，也是按值传递，即会复制整个结构。所以，如果传递给函数的结构很大，使用指针的方式效率通常比复制整个结构的效率要高。</p>
<p>结构指针使用广泛，C语言提供了一种更加方便的方式访问结构变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;结构成员</span><br></pre></td></tr></table></figure>
<h2 id="自引用结构"><a href="#自引用结构" class="headerlink" title="自引用结构"></a>自引用结构</h2><p>在结构中，可以包含自身引用，如二叉树结点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node &#123;</span><br><span class="line">    <span class="keyword">char</span> *word;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">struct</span> node *left;</span><br><span class="line">    <span class="keyword">struct</span> node *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>C语言提供了一个称为<code>typedef</code>功能，它用来建立新的数据类型名，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Length;</span><br></pre></td></tr></table></figure>
<p>类型<code>Length</code>与<code>int</code>具有相同的意义。</p>
<p><code>typedef</code>声明并没有创建一个新的类型，它只是为某个已存在的类型增加了一个新的名称而已。<code>typedef</code>声明也没有增加任何新的语义。实际上，<code>typedef</code>类似于<code>#define</code>语句，但由于<code>typedef</code>是由编译器解析的，因此它的文本替换功能要超过预处理器的能力。</p>
<p><code>typedef</code>有两个明显的好处：</p>
<ol>
<li><code>typedef</code>声明的数据类型同机器无关，移植到其他机器上时，只需要改变定义即可</li>
<li>为程序提供了更好的说明性</li>
</ol>
<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>联合是可以（在不同时刻）保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。联合提供了一种方式，在单块存储区中管理不同类型的数据，而不需要在程序中嵌入任何同机器有关的信息。</p>
<p>联合的目的是，一个变量可以合法地保存多种数据类型中任何的一种。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> tag &#123;</span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="keyword">float</span> fval;</span><br><span class="line">    <span class="keyword">char</span> *sval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上，<strong>联合就是一个结构</strong>，它的所有成员相对于基地址的偏移量都为0，此结构空间要大到足够容纳最宽的成员，并且，其对齐方式要适合于联合中所有类型的成员。联合只能用其第一个成员类型进行初始化。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/23/review-c-2/" itemprop="url">
                  重学C语言（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-23T22:53:35+08:00" content="2015-07-23">
              2015-07-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/23/review-c-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/23/review-c-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h2><blockquote>
<p>指针，是一种保存变量地址的变量。</p>
</blockquote>
<p>通常，机器都有一系列连续编号或编址的存储单元，这些存储单元可以单个进行操作也可以连续成组的方式操作。<strong>指针是能够存放一个地址的一组存储单元</strong>。</p>
<p>一元运算符<code>&amp;</code>用于取一个对象的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *point = &amp;count;</span><br></pre></td></tr></table></figure>
<p>地址运算符<code>&amp;</code>只能应用于<strong>内存中的对象</strong>，即变量与数组元素。它不能用于表达式、常量或<code>register</code>类型的变量。</p>
<p>一元运算符<code>*</code>是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象。</p>
<p>指针只能指向某种特定类型的对象。也就是说，每个指针都必须指向某种特定数据类型。一个例外情况是指向<code>void</code>类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。</p>
<h2 id="指针与函数参数"><a href="#指针与函数参数" class="headerlink" title="指针与函数参数"></a>指针与函数参数</h2><p>C语言是以<strong>传值</strong>的方式将参数传递给被调用函数。因此，被调用函数不能直接修改主调用函数中变量的值。</p>
<h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>在C语言中，通过数组下标所能完成的任何操作都可以通过指针来实现。一般来说，用指针编写和程序比用数组下标编写的程序执行速度快。</p>
<p>无论数组中元素的类型或数组长度是什么，“指针加1”就意味着指向指针所指的下一个对象。一个通过数组和下标实现的表达式可等价地通过指针和偏移量来实现。</p>
<p><strong>但是指针是一个变量，而数组名不是变量！</strong></p>
<p>当把数组名传递给一个函数时，实际上传递的是该数组第一个元素的地址。</p>
<p>在函数定义中，形式参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[];</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s;</span><br></pre></td></tr></table></figure>
<p>是等价的。</p>
<h2 id="地址算术运算"><a href="#地址算术运算" class="headerlink" title="地址算术运算"></a>地址算术运算</h2><p>对指针有意义的初始化只能是0或者是表示地址的表达式。C语言保证，0永远不是有效的数据地址。</p>
<p>指针与整数之间不能相互转换，但0是惟一例外。常量0可以赋值给指针，指针也可以和常量0进行比较。</p>
<p>如果指针p和q指向同一个数组的成员，那么它们之间就可以进行类似<code>==</code>、<code>!=</code>、<code>&lt;</code>的关系运算。但是，指向不同数组的元素的指针之间的算术或比较运算没有定义。</p>
<p>指针可以和整数进行相加减：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p + n</span><br></pre></td></tr></table></figure>
<p>表示指针<code>p</code>当前指向的对象之后第n个对象的地址。计算<code>p + n</code>时，n将根据<code>p</code>指向的对象的长度按比例缩放，而p指向的对象的长度则取决于<code>p</code>的声明。</p>
<p>指针减法也是有意义的：如果p和q指向相同数组中的元素，且<code>p &lt; q</code>，那么<code>q - p + 1</code>就是位于<code>p</code>和<code>q</code>指向元素之间的元素数目。</p>
<p>指针算术具有一致性：如果处理的数据类型是比字符型占更多存储空间的浮点类型，并且<code>p</code>是一个指向浮点类型的指针，那么在执行<code>p++</code>后，p将指向下一个浮点数的地址。</p>
<h2 id="字符指针与函数"><a href="#字符指针与函数" class="headerlink" title="字符指针与函数"></a>字符指针与函数</h2><blockquote>
<p>字符串常量是一个字符数组，以<code>\0</code>结尾。</p>
</blockquote>
<p>下面两个定义有很大的区别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> amessage[] = <span class="string">"now is the time"</span>;</span><br><span class="line"><span class="keyword">char</span> *pmessage = <span class="string">"noew is the time"</span>;</span><br></pre></td></tr></table></figure>
<p><code>amessage</code>是一个仅仅足以存放初始化字符串以及空字符<code>\0</code>的一维数组。数组中单个字符可以进行修改，但<code>amessae</code>始<strong>终指向同一个存储位置</strong>。另一方面，<code>pmessage</code>是指针，其初值指向一个字符串常量，之后它可以被修改以指向其他地址，但如果试图修改字符串的内容，结果是没有定义的。</p>
<h2 id="多维数组与指针"><a href="#多维数组与指针" class="headerlink" title="多维数组与指针"></a>多维数组与指针</h2><p>如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数，数组的行数没有太大关系。因为函数调用是传递的是一个指针，它指向由行向量构成的一维数组，其中每个行向量的长度必须指定。</p>
<p>假如有如下两个定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> *b[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p><code>a</code>是一个真正的二维数组，它分配了200个<code>int</code>类型长度的存储空间；但是，对<code>b</code>来说，该定义仅仅分配了10个指针，并且没有对它们进行初始化，它们的初始化必须以显式的方式进行，比如静态初始化或通过代码初始化。</p>
<p>指针数组的一个重要优点在于，<strong>数组的每一行长度可以不同</strong>。</p>
<h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><p>在C语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数作为函数的返回值等等。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/23/review-c-1/" itemprop="url">
                  重学C语言（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-23T00:31:03+08:00" content="2015-07-23">
              2015-07-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index">
                    <span itemprop="name">Coding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/23/review-c-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/23/review-c-1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大学四年有一个遗憾就是没学习C/C++。如今工作一年多了，能算得上熟练的语言也只有Java一门。总有一种不安，自己所学的东西都只是停留在皮毛之上，深入的东西并不多。那就重新开始吧！重新给自己打一次基础，第一部分就是C语言。</p>
<p>以一个Javaer的眼光来学，并不会记录太多相同的地方。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>变量</strong>其实就是一段内存空间。不同的数据类型也就是<strong>不同的内存长度以及对这段内存不同的解读方式</strong>。</p>
<p>C语言中有以下几种基本数据类型：</p>
<ul>
<li><code>char</code> 字符型，一个字节，存放一个字符</li>
<li><code>int</code> 整型，一般是所用机器中整数的最自然长度，一般32位</li>
<li><code>short</code> 短整型，一般16位</li>
<li><code>long</code> 长整型，一般64位</li>
<li><code>float</code> 单精度浮点型，一般32位</li>
<li><code>double</code> 双精确度浮点型，一般64位</li>
</ul>
<p>C99之前并没有<code>bool</code>类型！！！</p>
<p><strong>注意：</strong>数据类型的长度并不是固定的。<code>short</code>类型通常为16位、<code>long</code>类型通常为64位、<code>int</code>可以为16位或32位。</p>
<p>有如下限制：<code>short</code>与<code>int</code>类型至少为16位，而<code>long</code>类型至少为32位，并且<code>short</code>类型不得长于<code>int</code>类型，而<code>int</code>类型不得长于<code>long</code>类型。</p>
<p>作为对比，Java的基本数据类型如下：</p>
<ul>
<li>整型<ul>
<li><code>byte</code> 8位</li>
<li><code>short</code> 16位</li>
<li><code>int</code> 32位</li>
<li><code>long</code> 64位</li>
</ul>
</li>
<li>浮点型<ul>
<li><code>float</code> 32位，小数点后7位有效数字</li>
<li><code>double</code> 64位，小数点后15位有效数字</li>
</ul>
</li>
<li>字符型<ul>
<li><code>char</code> 8位</li>
</ul>
</li>
<li>布尔型<ul>
<li><code>boolean</code> true或false</li>
</ul>
</li>
</ul>
<p>在C语言中整型可以加<code>unsigned</code>表示无符号类型。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>枚举</strong>是一个常量整型值的列表。在没有显式说明的情况下，<code>enum</code>类型中第一个枚举名的值为0，第二个为1，依此类推。如果只指定部分枚举名的值，那么未指定值的枚举名将依着最后一个指定值向后递增。</p>
<p>如果变量不是自动变量，则只能进行一个初始化操作，从概念上讲，应该是在程序开始执行之前进行，并且初始化表达式必须为常量表达式。默认情况下，外部变量与静态变量将被初始化为0。未经显式初始化的自动变量的值为未定义值。</p>
<p><code>const</code>限定变量的值不能被修改，对于数组，所有元素的值都不能被修改。</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>根据定义，在关系表达式或逻辑表达式中，如果关系为真，则表达式的结果值为数值1；如果为假，则结果为0.</p>
<p>逻辑非运算符<code>!</code>的作用是将非0操作数转换为0，将操作数0转换为1。</p>
<p>C语言中<strong>非0</strong>与<strong>真</strong>是等价的。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数</strong>作用是把不需要他人了解的细节隐藏起来，使整个程序结构更加清晰，并降低修改程序的难度。</p>
<p>如果函数定义中省略了返回值类型，则默认为返回<code>int</code>类型。</p>
<p>程序可以看成是变量定义和函数定义的集合。函数之间的通信可以通过参数、函数返回值以及外部变量进行。</p>
<p>C语言程序可以看成由一系列的外部对象构成，这些外部对象可能为变量或函数。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>名字的作用域指的是程序中可以使用该名字的部分。对于在函数开头声明的自动变量来说，其作用域是声明该变量名的函数。</p>
<p>外部变量或函数作用域从声明它的地方开始，到其所在文件末尾结束。 如果要在外部变量定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性使用关键字<code>extern</code>。</p>
<p><strong>声明</strong>说明变量的属性、<strong>定义</strong>则会引起存储器的分配。一个外部变量只能在某个文件中定义一次，而其他文件可以通过<code>extern</code>声明来访问它。外部变量定义中必须指定数组长度，但<code>extern</code>声明则不一定要指定数组长度。</p>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>用<code>static</code>声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。即隐藏外部对象。</p>
<p><code>static</code>也可用于声明内部变量。<code>static</code>类型的内部变量同自动变量一样，是某个特定函数的局部变量，只能在该函数中使用，但它与自动变量不同的是，不管其他所在函数是否被调用，它一直存在。即，<code>static</code>类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。</p>
<h2 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h2><p><code>register</code>声明告诉编译器，该变量的使用频率较高，将变量放在寄存器可以使程序执行速度更快。但编译器可以忽略此选项。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为0，而自动变量和寄存器变量的初值则没有定义。</p>
<h2 id="C预处理器"><a href="#C预处理器" class="headerlink" title="C预处理器"></a>C预处理器</h2><p>从概念上讲，预处理器是编译过程中单独执行的第一个步骤。</p>
<p>宏替换是将所有出现名字记号的地方都将被替换为替换文本。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/20/five-important-habits/" itemprop="url">
                  五个重要的习惯
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-20T14:45:16+08:00" content="2015-06-20">
              2015-06-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Grow-up/" itemprop="url" rel="index">
                    <span itemprop="name">Grow up</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/06/20/five-important-habits/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/20/five-important-habits/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="保持头脑健康-Your-Mind"><a href="#保持头脑健康-Your-Mind" class="headerlink" title="保持头脑健康 Your Mind"></a>保持头脑健康 Your Mind</h2><p>你的大脑控制着你的想法，而你的想法影响着身边的一切。</p>
<ul>
<li>每天读点书——思考</li>
<li>每天写点东西——表达</li>
<li>每天记点东西——积累</li>
<li>每天做点东西——实践</li>
<li>保持你的好奇心</li>
</ul>
<h2 id="照顾好你的身体-Your-Body"><a href="#照顾好你的身体-Your-Body" class="headerlink" title="照顾好你的身体 Your Body"></a>照顾好你的身体 Your Body</h2><p>身体是革命的本钱，而一个好身体总离不开健康饮食与运动</p>
<ul>
<li>活动你不经常动到的肌肉与骨骼，不要让它们退化了</li>
<li>合理的饮食，足够的能量、水分等等</li>
</ul>
<h2 id="关注你的人际关系-Your-Relationships"><a href="#关注你的人际关系-Your-Relationships" class="headerlink" title="关注你的人际关系 Your Relationships"></a>关注你的人际关系 Your Relationships</h2><p>和你走完人生旅途的，不只有你的家人爱人，还有一路结识的朋友。</p>
<ul>
<li>记住别人的信息</li>
<li>学会宽恕与感恩</li>
<li>形成你的圈子，当然也让一些人远离你的圈</li>
</ul>
<h2 id="关注你的财务-Finances"><a href="#关注你的财务-Finances" class="headerlink" title="关注你的财务 Finances"></a>关注你的财务 Finances</h2><p>钱不是万能，但没钱万万不能。财富不只是钱，你需要好好打理。</p>
<ul>
<li>赚钱——合理合法合乎情理付出得到的回报</li>
<li>消费——必要消费、冲动消费、投资等等</li>
</ul>
<h2 id="沟通-Communication"><a href="#沟通-Communication" class="headerlink" title="沟通 Communication"></a>沟通 Communication</h2><p>与其他的人分享你的意见与想法。</p>
<ul>
<li>把复杂的东西用自己的话解释清楚</li>
<li>简短准确地描述你的想法</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://0.gravatar.com/avatar/399760be5a90853cc8acc00569530897"
               alt="yjiyjige" />
          <p class="site-author-name" itemprop="name">yjiyjige</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">15</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yjiyjige</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yjiyjige"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  


</body>
</html>
